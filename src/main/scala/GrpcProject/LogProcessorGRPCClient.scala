package GrpcProject

import HelperUtils.{CreateLogger, ObtainConfigReference}
import com.grpcLogProcessor.protos.LogProcessor.LogProcessServiceGrpc.LogProcessServiceStub
import com.grpcLogProcessor.protos.LogProcessor.{LogProcessServiceGrpc, LogProcessorReply, LogProcessorRequest}
import com.typesafe.config.Config
import io.grpc.{ManagedChannel, ManagedChannelBuilder}
import org.slf4j.Logger

import scala.concurrent.ExecutionContext.Implicits.global
import scala.concurrent.duration.Duration
import scala.concurrent.{Await, Future}
import scala.util.{Failure, Success}

/**
 * This object represents GRPC Client program
 */
object LogProcessorGRPCClient {

  // configs
  val configReference: Config = ObtainConfigReference("grpc") match {
    case Some(value) => value
    case None => throw new RuntimeException("Cannot obtain a reference to the config data.")
  }
  val config: Config = configReference.getConfig("grpc")
  val logger: Logger = CreateLogger(classOf[LogProcessorGRPCClient.type])

  /**
   * Apply method for the object
   * @param host - host of GRPC Server
   * @param port - port of GRPC Server
   * @return - reference to LogProcessorGRPCClient object
   */
  def apply(host: String, port: Int): LogProcessorGRPCClient = {
    val channelBuilder = ManagedChannelBuilder.forAddress(host, port)
    channelBuilder.usePlaintext()
    val channel = channelBuilder.build()
    val stub = LogProcessServiceGrpc.stub(channel)
    new LogProcessorGRPCClient(channel, stub)
  }

  // Client class
  class LogProcessorGRPCClient (
    private val channel: ManagedChannel,
    private val stub: LogProcessServiceStub
                                      ) {
    // shuts down the channel
    def shutdown(): Unit = {
      channel.shutdown()
    }

    /**
     * This method processes log file by performing a RPC using stub that is generated by Proto compiler
     * @param date - date of logs
     * @param time - start time of logs to process (t)
     * @param interval - interval to search in between (dt)
     * @return - Future of GRPC Reply (logs data in MD5 hash for (t, t+dt) range)
     */
    def processLogs(date: String, time: String, interval: Int): Future[LogProcessorReply] = {
      val grpcRequest = LogProcessorRequest(date = date, time = time, interval = interval)
      stub.processLogs(grpcRequest)
    }
  }

  /**
   * Entry point for client program
   * @param args - default arguments passed from cli or run configs
   */
  def main(args: Array[String]): Unit = {
    val grpcClient = LogProcessorGRPCClient(config.getString("host"), config.getInt("port"))
    val resultsFuture = grpcClient.processLogs(config.getString("dateToProcess"), config.getString("timeToProcess"), config.getInt("intervalToProcessInSeconds"))

    // logs the response as well as the error
    resultsFuture onComplete {
      case Success(value) =>
        logger.info(s"GRPC Server Response: ${value.response}, with status code: ${value.statusCode.intValue}")
        grpcClient.shutdown()
      case Failure(exception) =>
        logger.error(exception.getMessage)
        grpcClient.shutdown()
    }

    // wait for the future to resolve
    Await.ready(resultsFuture, Duration.Inf)
  }

}
