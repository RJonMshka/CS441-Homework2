package GrpcProject

import HelperUtils.{CreateLogger, ObtainConfigReference}
import com.grpcLogProcessor.protos.LogProcessor.{LogProcessServiceGrpc, LogProcessorReply, LogProcessorRequest}
import com.typesafe.config.Config
import io.grpc.Server
import io.grpc.netty.NettyServerBuilder
import org.slf4j.Logger

import scala.concurrent.duration.FiniteDuration
import scala.concurrent.{Await, ExecutionContext, Future}


/**
 * This object holds the logic for GRPC Server
 */
object LogProcessorGRPCServer {
  // configs
  val configReference: Config = ObtainConfigReference("grpc") match {
    case Some(value) => value
    case None => throw new RuntimeException("Cannot obtain a reference to the config data.")
  }
  val config: Config = configReference.getConfig("grpc")
  val logger: Logger = CreateLogger(classOf[LogProcessorGRPCServer.type])

  private val port = config.getInt("port")

  /**
   * This method returns server port
   * @return server port
   */
  def getServerPort: Int = port

  /**
   * Main entry point for the GRPC Server - it starts the server
   * @param args - default argument from run configs
   */
  def main(args: Array[String]): Unit = {
    val grpcServer = new LogProcessorGRPCServer(ExecutionContext.global)
    grpcServer.startServer()
  }

  /**
   * LogProcessorGRPCServer
   * @param executionContext - Execution context for the server
   */
  private class LogProcessorGRPCServer(private val executionContext: ExecutionContext) {

    /**
     * This method starts the server
     */
    def startServer(): Unit = {
      val serverBuilder = NettyServerBuilder.forPort(LogProcessorGRPCServer.port)
      serverBuilder.addService(LogProcessServiceGrpc.bindService(new LogProcessServiceImpl, this.executionContext))
      val server = serverBuilder.build().start()

      logger.info(s"GRPC Server started at port: ${LogProcessorGRPCServer.port}")
      // run when the server is shutdown by any event
      sys.addShutdownHook {
        logger.info("shutting down gRPC server since JVM is shutting down")
        this.stop(server)
        logger.info("server shut down")
      }
      // this will await manual termination
      this.blockUntilShutdown(server)
    }

    /**
     * This method stops the server from running
     * @param server - server object
     */
    private def stop(server: Server): Unit = {
      if(server != null) {
        server.shutdown()
      }
    }

    /**
     * This method block the termination of server immediately
     * @param server - server object
     */
    private def blockUntilShutdown(server: Server): Unit = {
      if (server != null) {
        server.awaitTermination()
      }
    }

  }

  /**
   * This class is Server implementation of Server stub generated by Proto compile by compiling Protobuff file
   */
  private class LogProcessServiceImpl extends LogProcessServiceGrpc.LogProcessService {

    /**
     * Method that needs implementation - actual server side logic of GRPC
     * @param request - incoming request
     * @return - Future of Reply
     */
    override def processLogs(request: LogProcessorRequest): Future[LogProcessorReply] = {
      val date = request.date
      val time = request.time
      val interval = request.interval

      // Transfers control to Akka HTTP Client to interact with API Gateway
      // which will in-turn return result from lambda function, which processes log files
      val httpserverResponseFutureTuple = LogProcessorGRPCRestClient.processHttpRequest(date, time, interval)

      val response = Await.result(httpserverResponseFutureTuple._1, FiniteDuration(config.getInt("timeoutInSeconds"), config.getString("secondsText")))
      val status = Await.result(httpserverResponseFutureTuple._2, FiniteDuration(config.getInt("timeoutInSeconds"), config.getString("secondsText")))

      val reply = LogProcessorReply(response, status.intValue)
      Future.successful(reply)
    }
  }

}
